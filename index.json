{
  "api/index.html": {
    "href": "api/index.html",
    "title": "aas-core 3.1 C# API",
    "keywords": "aas-core 3.1 C# API The API of the SDK is split into six different units: Namespace Description AasCore.Aas3_1 Create the model programmatically AasCore.Aas3_1.Visitation Iterate over and transform the model AasCore.Aas3_1.Constants Specify constants such as constant sets of strings AasCore.Aas3_1.Verification Verify that the model fulfills the constraints AasCore.Aas3_1.Jsonization De/serialize from/to JSON AasCore.Aas3_1.Xmlization De/serialize from/to XML AasCore.Aas3_1.Enhancing Wrap and enhance instances of the model Please refer to Getting Started for a brief introduction on how to use the API."
  },
  "change_log.html": {
    "href": "change_log.html",
    "title": "Change Log",
    "keywords": "Change Log 1.0.0-rc1 (2025-12-09) This is the first public version."
  },
  "contributing.html": {
    "href": "contributing.html",
    "title": "Contributing",
    "keywords": "Contributing Issues Please report bugs or feature requests by creating GitHub issues . In Code If you want to contribute in code, pull requests are welcome! Please do create a new issue before you dive into coding. It can well be that we already started working on the feature, or that there are upstream or downstream complexities involved which you might not be aware of. SDK Code Generation The biggest part of the code has been automatically generated by aas-core-codegen . It probably makes most sense to change the generator rather than add new functionality. However, this needs to be decided on a case-by-case basis. Build To build the solution, run: dotnet build src/ Pre-commit Checks Before you can run pre-commit checks, you need to install the tools from src/ directory: cd src dotnet tool restore Now you can execute the checks (from the repository root): powershell src/Check.ps1 Pull Requests Feature branches . We develop using the feature branches, see this section of the Git book . If you are a member of the development team, create a feature branch directly within the repository. Otherwise, if you are a non-member contributor, fork the repository and create the feature branch in your forked repository. See [this GitHub tuturial] for more guidance. Branch Prefix . Please prefix the branch with your Github user name ( e.g., mristin/Add-some-feature ). Continuous Integration . GitHub will run the continuous integration (CI) automatically through GitHub actions. The CI includes building the solution, running the test, inspecting the code etc. If you installed all the tools (by dotnet tool restore , see above), you can run the CI checks locally: powershell src/Check.ps1 Commit Messages The commit messages follow the guidelines from https://chris.beams.io/posts/git-commit : Separate subject from body with a blank line, Limit the subject line to 50 characters, Capitalize the subject line, Do not end the subject line with a period, Use the imperative mood in the subject line, Wrap the body at 72 characters, and Use the body to explain what and why (instead of how )."
  },
  "design_decisions.html": {
    "href": "design_decisions.html",
    "title": "Design Decisions",
    "keywords": "Design Decisions We explain a couple of design decisions and trade-offs we deliberately made during the development of the SDK. These are our opinions â€” you may or may not agree, which is totally OK as there are always more than one way to do things and do them well. However, the decisions elaborated here are not meant to convince you. We want to give you insight about why we did certain things, and why we didn't implement them in some other way. Aggregations as Lists instead of Dictionaries We decided to implement all the aggregations in the meta-model as System.Collections.Generic.List instead of System.Collections.Generic.Dictionary . Some structures just \"scream\" for a dictionary, such as SubmodelElements property in a Submodel . The submodel elements need to be unique w.r.t. their ID-shorts. So why didn't we model them as dictionaries, where keys are ID-shorts? There are multiple reasons: \"There are only two hard things in Computer Science: cache invalidation and naming things\" (see this StackExchange ). For example, the key in the dictionary and the IdShort property of the submodel element need to be always in sync. Keeping such things in sync can be hard. When de-serializing, you need to hash on all the key/value pairs. In many situations, you do not perform any look-ups, but want to read the whole environment only once, and act upon it. Hashing would have wasted computational resources. You may want to index on more things than IdShort . For example, retrieving submodel elements by their SemanticId is almost equally important. The order of the key/value pairs in a dictionary might not follow the order in the underlying serialized file. For example, if System.Collections.HashTable is used, the order is random. This would make the round-trip de-serialization ðŸ ’ serialization non-deterministic. Generating code based on dictionaries would have incurred additional complexity in aas-core-meta and aas-core-codegen as we would need to capture indexing in our machine-readable meta-models. We therefore leave indexing (and syncing of the indices) to the user instead of pre-maturely providing a basic index on one of the features. No Parent âŸ· Child Associations We did not model the parent âŸ· child relations between the model elements for similar reasons why we did not implement dictionaries. Namely, keeping the associations in sync is hard. While you might have clear parent âŸ· child relationship when you deserialize an environment, this relationship becomes less clear when you start re-using objects between environments. Moreover, you need to sync the parent when an instance associated as its child is deleted. The complexity of this sync becomes hard (and computationally costly) as your object tree grows. And what if you re-assign the instance to multiple parents? For example, an instance of Submodel may appear in multiple instances of Environment . Which environment is the parent? Multiple solutions are possible, and they depend on the application domain. In some cases, where you deal with static data, a simple dictionary parent ðŸ ’ child is sufficient. In other cases, more involved data structures and updating strategies are needed. As we did not want to prejudice the SDK for a particular application domain, we left out parent âŸ· child associations. We indeed discussed a couple of concrete solutions, but failed to find a unifying approach which would satisfy multiple scenarios. Please create an issue if you would like to discuss this point further. Values as Strings As you can see, say, in [Property] class, the Value property holds strings. This is indeed intentional though it might seem a bit outlandish. You have to bear in mind that the lexical space of XML basic data types , which we use to encode values in such properties, is large, and larger than C# primitive types. For example, xs:double 's can have an arbitrary prefix of zeros ( 001234 is a valid xs:double ). For another example, xs:decimal allows for an arbitrary size and precision. In C#, System.Decimal is probably our best bet, but it has a fixed precision. It might well be that our application domain requires more precision than System.Decimal ! Writing code for a setting where various systems interoperate with mixed application domains is difficult. We wanted to stick to the specification, which mandates XML basic data types , and thus leave the parsing of values up to the users. Thus, we do not restrict the domain where our SDK can be used. The users will know the best what precision and form they need. No AAS Registry An AAS Registry is considered an external dependency, since it requires network requests. We left it out-of-scope on purpose as this SDK focuses on the data exchange. Further aas-core projects will work on an AAS registry. One important consequence of leaving out the registry is that some constraints in the meta-model can not be enforced, as we do not know how to resolve the references. The full list of omitted constraints is available in the code of aas-core-meta . Build Your Own Abstraction on Top We intentionally kept the API surface of the SDK minimal. The idea was to give you basic building blocks which you can use to construct more complex structures. For example, LINQ in conjunction with Descend method of IClass allows for powerful queries. An implementation of AbstractVisitor or AbstractTransformer allows you to write converters to other formats. They give you a pre-structured code which you merely need to fill in, thus reducing your mental overhead. Maintainability versus Performance We chose to sacrifice the performance for maintainability of the code. In particular, we decided to generate the code automatically using aas-core-codegen . This imposed certain suboptimal spots in the code. For example, the constraints are automatically transpiled. A lot of constraints could have been optimized, but we are stuck with their representation in Python and the way they are translated into C#. We believe that this is a valid trade-off at the moment. At the moment, the meta-model changes too frequently to manually come up with the changes in an SDK without sacrificing the correctness. As more critical applications and domains in the AAS space arise, and the meta-model becomes more stable, hand optimization of certain parts of our SDK will probably make more sense."
  },
  "getting_started/create_get_set.html": {
    "href": "getting_started/create_get_set.html",
    "title": "Create, Get and Set Properties of an AAS Model",
    "keywords": "Create, Get and Set Properties of an AAS Model The namespace AasCore.Aas3_1 contains all the classes of the meta-model. You can simply use their constructors to create an AAS model. Usually you start bottom-up, all the way up to the AasCore.Aas3_1.Environment . Getters and Setters For each property in the meta-model, there is a corresponding getter and setter. For example, see the getter and setter for AasCore.Aas3_1.Submodel.Category . Getters with a Default Value For optional properties which come with a default value, we provide special getters, {property name}OrDefault . If the property has not been set, this getter will give you the default value. Otherwise, if the model sets the property, the value of the property will be returned. For example, see AasCore.Aas3_1.Submodel.KindOrDefault . Example: Create an environment with a submodel Here is a very rudimentary example where we show how to create an environment which contains a submodel. The submodel will contain two elements, a property and a blob. (We will alias the namespace AasCore.Aas3_1 to Aas for readability. You might or might not want to write your code like that; the aliasing is not necessary.) using System.Collections.Generic; using Aas = AasCore.Aas3_1; public class Program { public static void Main() { // Create the first element var someElement = new Aas.Property( Aas.DataTypeDefXsd.Int) { IdShort=\"someElement\", Value=\"1984\" }; // Create the second element var content = new byte[] { 0xDE, 0xAD, 0xBE, 0xEF }; var anotherElement = new Aas.Blob( \"application/octet-stream\") { IdShort=\"anotherElement\", Value=content }; // You can also directly access the element properties anotherElement.Value[3] = 0xED; // Nest the elements in a submodel var elements = new List<Aas.ISubmodelElement>() { someElement, anotherElement }; var submodel = new Aas.Submodel( \"someIdShort\", \"some-unique-global-identifier\") { SubmodelElements = elements }; // Now create the environment to wrap it all var submodels = new List<Aas.ISubmodel>() { submodel }; var environment = new Aas.Environment() { Submodels = submodels }; // You can access the properties from the children // as well. ( environment .Submodels[0] .SubmodelElements[1] as Aas.Blob ).Value[3] = 0xEF; // Now you can do something with the environment... } }"
  },
  "getting_started/enhancing.html": {
    "href": "getting_started/enhancing.html",
    "title": "Enhancing",
    "keywords": "Enhancing In any complex application, creating, modifying and de/serializing AAS instances is not enough. You have to insert your custom application-specific data to the model in order for the model to be useful. Take, for example, parent-child relationship. The current library ignores it, and there is no easy way for you to find out to which Submodel a particular ISubmodelElement belongs to. We did want to keep the types as simple as possible â€” the parent-child relationships can get tricky very soon if you have multiple environments with shared submodels etc. Instead of overcomplicating the code and making it barely traceable, we decided to keep it simple and frugal in features. However, that is little solace if you are developing an GUI editor where you know for sure that there will be only one environment, and where parent-child relationships are crucial for so many tasks. What is more, parent-child relationships are not the only data that need to be intertwined â€” you probably want history, localized caches etc. Hasthable? There are different ways how application-specific data can be synced with the model. One popular technique is to use Hashtable 's and simply map model instances to your custom nuggets of data. This works well if the data is read-only, and you can spare the cycles for the lookups (which is often acceptable as they run on average in time complexity O(1) anyhow). Otherwise, if you need to modify the data, maintaining the consistency between the Hashtable and your nuggets becomes difficult. For example, if you forget to remove the entries from the Hashtable when you remove the instances from the model, you might clog your garbage collector. Wrapping Hence, if you modify the data, you need to keep it close to the model instance. In dynamic languages, such as Python and JavaScript, you can simply add your custom fields to the object. This does not work in such a static language like C#. One solution, usually called Decorator pattern , is to wrap or decorate the instances with your application-specific data. The decorated objects should satisfy both the interface of the original model and provide a way to retrieve your custom nuggets of information. Writing wrappers for many classes in the AAS meta-model is a tedious task. We therefore pre-generated the most of the boilerplate code in the static class Enhancing . In the context of decoration, we call your specific data enhancements . First, you need to specify how individual instances are enhanced, i.e. how to produce enhancements for each one of them. We call this an enhancement factory . Second, you need to recursively wrap your instances with the given enhancement factory. The Enhancing is generic and can work with any form of enhancement classes. You need to specify your enhancement factory as a function delegate which takes an instance of IClass as input and returns an enhancement, or null , if you do not want to enhance the particular instance. The wrapping and unwrapping is specified in the generic class Enhancer , which takes the enhancement factory as the only argument. The methods Enhancer.Wrap and Enhancer.Unwrap perform the wrapping and unwrapping, respectively. The method Enhancer.MustWrap is a shortcut method that spares you a non-null check of Enhancer.Unwrap . Example: Parent-Child Enhancement Let us now consider the aforementioned example. We want to keep track of parent-child relationships in a model. The following code snippets first constructs an environment for illustration. Then we specify the enhancement such that each instance is initialized with the parent set to null . Finally, we modify the enhancements such that they reflect the parent-child relationships. using Aas = AasCore.Aas3_1; using AasEnhancing = AasCore.Aas3_1.Enhancing; using System.Linq; using System.Collections.Generic; public class Program { class Enhancement { public Aas.IClass? Parent = null; } public static void Main() { // Prepare the environment var someProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"someProperty\", }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { someProperty } }; Aas.IEnvironment environment = new Aas.Environment() { Submodels = new List<Aas.ISubmodel>() { submodel } }; // Prepare the enhancer var enhancer = new Aas.Enhancing.Enhancer<Enhancement>( (instance => new Enhancement()) ); // Enhance with parent set to `null` environment = (Aas.IEnvironment) enhancer.Wrap(environment); var queue = new Queue<Aas.IClass>(); queue.Enqueue(environment); while (queue.Count > 0) { var instance = queue.Dequeue(); foreach (var child in instance.DescendOnce()) { enhancer.MustUnwrap(child).Parent = instance; queue.Enqueue(child); } } // Retrieve the parent of the first submodel System.Console.WriteLine( enhancer.MustUnwrap(environment.Submodels![0]).Parent == environment ); // Prints: // True } } Note that this approach is indeed more maintainable than the one with Hashtable , but you still need to take extra care. If you create new submodels and insert them into the environment, you have to make sure that you wrap them appropriately. If you move a submodel from one environment to another, you have to update the parent link manually etc. Example: Selective Enhancement We demonstrate now how you can selectively enhance only some instances in the Environment . For example, let us assign a unique identifier to all instances which are referable, i.e. , implement IReferable . All the other instances are not enhanced. using Aas = AasCore.Aas3_1; using AasEnhancing = AasCore.Aas3_1.Enhancing; using System.Linq; using System.Collections.Generic; public class Program { class IdEnhancement { public long Id; public IdEnhancement(long id) { Id = id; } } public static void Main() { // Prepare the environment Aas.IEnvironment environment = new Aas.Environment() { Submodels = new List<Aas.ISubmodel>() { new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"someProperty\", } }, Administration = new Aas.AdministrativeInformation() { Version=\"1.0\" } } } }; // Prepare the enhancer long lastId = 0; var enhancementFactory = new System.Func<IClass, IdEnhancement?>( instance => { if (instance is Aas.IReferable) { lastId++; return new IdEnhancement(lastId); } return null; } ); var enhancer = new Aas.Enhancing.Enhancer<IdEnhancement>( enhancementFactory ); // Enhance environment = (Aas.IEnvironment)enhancer.Wrap(environment); // The submodel and property are enhanced. IdEnhancement enhancement = enhancer.MustUnwrap(environment.Submodels![0]); System.Console.WriteLine(enhancement.Id); // Prints: // 2 enhancement = enhancer.MustUnwrap(environment.Submodels![0].SubmodelElements![0]); System.Console.WriteLine(enhancement.Id); // Prints: // 1 // The administrative information is not referable, and thus not enhanced. IdEnhancement? maybeEnhancement = enhancer.Unwrap( environment.Submodels![0].Administration! ); System.Console.WriteLine(maybeEnhancement == null); // Prints: // True } } No Re-wraps Allowed We disallow re-wraps of already wrapped instances to avoid costly iterations over the object trees, and throw an exception. Additionally, we want to prevent bugs in many settings where the enhancement factory assigns unique identifiers to instances or performs non-idempotent operations. Please let us know by [creating an issue] if you need re-wraps to be allowed, and please tell us more about your particular scenario. Separating Enhancing from Unwrapping The Enhancer class expects an enhancement factory. This forces you to define the unwrapping logic at the same site where you define the enhancement factory. While more often than not you do define the two in the same place, sometimes you want to separate them. For example, when the enhancement factory requires external dependencies which are unavailable at the time of unwrapping. To that end, we implemented the class Unwrapper , a parent of the Enhancer class, that is only concerned about unwrapping, and has no ties to the enhancement factory. Here is the above example related to unique IDs rewritten such that unwrapping and enhancing are separated: using Aas = AasCore.Aas3_1; using AasEnhancing = AasCore.Aas3_1.Enhancing; using System.Linq; using System.Collections.Generic; public class Program { class IdEnhancement { public long Id; public IdEnhancement(long id) { Id = id; } } private Aas.IEnvironment EnhanceSeparatedFromUnwrapping( Aas.IEnvironment environment ) { // Prepare the enhancer long lastId = 0; var enhancementFactory = new System.Func<IClass, IdEnhancement?>( instance => { if (instance is Aas.IReferable) { lastId++; return new IdEnhancement(lastId); } return null; } ); var enhancer = new Aas.Enhancing.Enhancer<IdEnhancement>( enhancementFactory ); // Enhance return (Aas.IEnvironment)enhancer.Wrap(environment); } public static void Main() { // Prepare the environment Aas.IEnvironment environment = new Aas.Environment() { Submodels = new List<Aas.ISubmodel>() { new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"someProperty\", } }, Administration = new Aas.AdministrativeInformation() { Version=\"1.0\" } } } }; // Enhance environment = EnhanceSeparatedFromUnwrapping(environment); // Define the unwrapping var unwrapper = new Aas.Enhancing.Unwrapper<IdEnhancement>(); // The submodel and property are enhanced. // ReSharper disable once NotAccessedVariable IdEnhancement enhancement = unwrapper.MustUnwrap(environment.Submodels![0]); System.Console.WriteLine(enhancement.Id); // Prints: // 2 } }"
  },
  "getting_started/install.html": {
    "href": "getting_started/install.html",
    "title": "Installation",
    "keywords": "Installation The SDK is available as a NuGet package AasCore.Aas3_1 . Change to your project's directory ( i.e , the directory where your .csproj file resides). Add the SDK as the dependency using dotnet : dotnet add package AasCore.Aas3_1 The SDK should be now available. You might probably need to re-start your IDE and re-build the solution for changes to take effect."
  },
  "getting_started/intro.html": {
    "href": "getting_started/intro.html",
    "title": "Getting Started with aas-core 3.1 C# SDK",
    "keywords": "Getting Started with aas-core 3.1 C# SDK Here's a quick intro to get you started with the SDK. See how you can: Install the SDK , Programmatically create, get and set properties of an AAS model , Iterate over, copy and transform a model , Verify a model , De/serialize a model from and to JSON , De/serialize a model from and to XML , and Enhance model instances with your custom data ."
  },
  "getting_started/iterate_copy_and_transform.html": {
    "href": "getting_started/iterate_copy_and_transform.html",
    "title": "Iterate, Copy and Transform",
    "keywords": "Iterate, Copy and Transform The SDK provides various ways how you can loop through the elements of the model, and how these elements can be transformed. Each following section will look into one of the approaches. OverXOrEmpty For all the optional lists, there is a corresponding Over{property name}OrEmpty getter. It gives you an System.Collection.IEnumerable . If the property is not set, this getter will give you an empty enumerable. Otherwise, it will return the enumerable over the list. For example, see OverSubmodelsOrEmpty in AasCore.Aas3_1.Environment.OverSubmodelsOrEmpty . DescendOnce and Descend If you are writing a simple script, want to use LINQ and do not care about the performance, the SDK provides two methods in the most general interface IClass , DescendOnce and Descend , which you can use to loop through the instances. Both DescendOnce and Descend iterate over model children of an IClass . DescendOnce , as it names suggests, stops after all the children has been iterated over. Descend continues recursively to grand-children etc. Here is a short example how you can get all the properties from an environment whose ID-short starts with another : using System.Collections.Generic; using System.Linq; using Aas = AasCore.Aas3_1; public class Program { public static void Main() { // Prepare the environment var someProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"someProperty\", }; var anotherProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"anotherProperty\" }; var yetAnotherProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"yetAnotherProperty\" }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { someProperty, anotherProperty, yetAnotherProperty } }; var environment = new Aas.Environment() { Submodels = new List<Aas.ISubmodel>() { submodel } }; // Iterate over all properties which have \"another\" // in the ID-short foreach ( var prop in environment .Descend() .OfType<Aas.IProperty>() .Where( prop => ( prop.IdShort != null && prop.IdShort.ToLower().Contains(\"another\") ) ) ) { System.Console.WriteLine(prop.IdShort); } // Outputs: // anotherProperty // yetAnotherProperty } } Iteration with Descend and DescendOnce works well if the performance is irrelevant. However, if the performance matters, this is not a good approach. First, all the children model elements will be visited (even though you need only a small subset). Second, the call to LINQ's OfType<Aas.IProperty> needs to perform a type cast for every child. Let's see in the next section how we could use a more efficient, but also a more complex approach. Visitor Visitor pattern is a common design pattern in software engineering. We will not explain the details of the pattern here as you can read about in the ample literature in books or in Internet. The cornerstone of the visitor pattern in double dispatch : instead of casting to the desired type during the iteration, we add a method Accept to IClass , whose implementations then directly dispatch to the appropriate method. This allows us to spare casts and directly dispatch the execution. The SDK already implements Accept methods, so you only have to implement the visitor. The visitor class has a visiting method for each class of the meta-model. In the SDK, we provide different flavors of the visitor abstract classes which you can readily implement: AbstractVisitor which needs all the visit methods to be implemented, VisitorThrough which visits all the elements and does nothing, and AbstractVisitorWithContext which propagates a context object along the iteration. Let us re-write the above example related to Descend method with a visitor pattern: using System.Collections.Generic; using Aas = AasCore.Aas3_1; using AasVisitation = AasCore.Aas3_1.Visitation; class Visitor : AasVisitation.VisitorThrough { public override void Visit(Aas.Property prop) { if (prop.IdShort.ToLower().Contains(\"another\")) { System.Console.WriteLine(prop.IdShort); } } }; public class Program { public static void Main() { // Prepare the environment var someProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"someProperty\", }; var anotherProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"anotherProperty\" }; var yetAnotherProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"yetAnotherProperty\" }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { someProperty, anotherProperty, yetAnotherProperty } }; var environment = new Aas.Environment() { Submodels = new List<Aas.ISubmodel>() { submodel } }; // Iterate over all properties which have \"another\" // in the ID-short var visitor = new Visitor(); visitor.Visit(environment); // Outputs: // anotherProperty // yetAnotherProperty } } There are important differences to iteration with Descend : Due to double dispatch , we spare a cast. This is usually more efficient. We can handle multiple types of the elements, not only a single type ( Property in this case). This can allow for better readability of the code as well as better performance if two or more element types need to be considered in one iteration. The iteration logic in Descend lives very close to where it is executed. In contrast, the visitor needs to be defined as a separate class. While sometimes faster, writing the visitor makes the code less readable. Descend or Visitor? In general, people familiar with the visitor pattern and object-oriented programming will prefer, obviously, visitor class. People who like LINQ will prefer Descend . It is difficult to discuss different tastes, so you should probably come up with explicit code guidelines in your code and stick to them. Make sure you always profile before you sacrifice readability and blindly apply one or the other approach for performance reasons. Shallow and Deep Copies In the static class [Copying], we provide methods for making shallow and deep copies of an instance of AAS model. In both manners of copying, primitive values (such as bool , string etc. ) are copied by value. Shallow copying copies all the non-primitive values by reference. The lists are also copied by reference, and no new lists are created in the copy. Deep copying makes a deep copy recursively, where we make a deep copy of all the underlying non-primitive values. Here is an example of how you can make a shallow and a deep copy of an [Environment]: using System.Collections.Generic; using System.Linq; using Aas = AasCore.Aas3_1; public class Program { public static void Main() { // Prepare the environment var someProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"someProperty\", }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { someProperty } }; var environment = new Aas.Environment() { Submodels = new List<Aas.ISubmodel>() { submodel } }; // Make a deep copy var deepCopy = Aas.Copying.Deep(environment); // Make a shallow copy var shallowCopy = Aas.Copying.Shallow(environment); // Changes to the property affect only the shallow copy, // but not the deep one environment.Submodels[0].SubmodelElements![0].IdShort = \"changed\"; System.Console.WriteLine( shallowCopy.Submodels![0].SubmodelElements![0].IdShort); System.Console.WriteLine( deepCopy.Submodels![0].SubmodelElements![0].IdShort); // Output: // changed // someProperty } } Transformer A transformer pattern is an analogous to visitor pattern , where we \"transform\" the visited element into some other form (be it a string or a different object). It is very common in compiler design, where the abstract syntax tree is transformed into a different representation. The SDK provides two different flavors of a transformer: AbstractTransformer , where the model element is directly transformed into something, and AbstractTransformerWithContext , which propagates the context object along the transformations. Since we need to provide a transformation method for each class of the meta-model, we deliberately omit an example due to the length of the code. If you need a practical example, see the source code of the Verification static class, where we implemented the verification logic using an AbstractTransformer ."
  },
  "getting_started/jsonize.html": {
    "href": "getting_started/jsonize.html",
    "title": "JSON De/serialization",
    "keywords": "JSON De/serialization Our SDK handles the de/serialization of the AAS models from and to JSON format through the static class Jsonization . Serialize To serialize, you call the method ToJsonObject of Jsonization.Serialize static class on an instance of Environment which will convert it to an instance of System.Text.Json.Nodes.JsonObject . Here is a snippet that converts the environment first into an System.Text.Json.Nodes.JsonObject , and next converts the JSON object to text: using System.Collections.Generic; using Aas = AasCore.Aas3_1; using AasJsonization = AasCore.Aas3_1.Jsonization; public class Program { public static void Main() { // Prepare the environment var someProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"someProperty\", }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { someProperty } }; var environment = new Aas.Environment() { Submodels = new List<Aas.ISubmodel>() { submodel } }; // Serialize to a JSON object var jsonObject = AasJsonization.Serialize.ToJsonObject( environment ); // Print the JSON object System.Console.WriteLine(jsonObject); // Outputs: // { // \"submodels\": [ // { // \"id\": \"some-unique-global-identifier\", // \"submodelElements\": [ // { // \"idShort\": \"someProperty\", // \"valueType\": \"xs:boolean\", // \"modelType\": \"Property\" // } // ], // \"modelType\": \"Submodel\" // } // ] // } } } De-serialize Our SDK can convert a System.Text.Json.Nodes.JsonNode back to an instance of Environment . All you have to do is call the method EnvironmentFrom from the static class Jsonization.Deserialize . Here is an example snippet: using Nodes = System.Text.Json.Nodes; using Aas = AasCore.Aas3_1; using AasJsonization = AasCore.Aas3_1.Jsonization; public class Program { public static void Main() { var text = @\"{ \"\"submodels\"\": [ { \"\"id\"\": \"\"some-unique-global-identifier\"\", \"\"submodelElements\"\": [ { \"\"idShort\"\": \"\"someProperty\"\", \"\"valueType\"\": \"\"xs:boolean\"\", \"\"modelType\"\": \"\"Property\"\" } ], \"\"modelType\"\": \"\"Submodel\"\" } ] }\"; var jsonNode = Nodes.JsonNode.Parse( text); // De-serialize from the JSON node Aas.Environment environment = ( AasJsonization.Deserialize.EnvironmentFrom( jsonNode) ); // Print the types of the model elements contained // in the environment foreach (var something in environment.Descend()) { System.Console.WriteLine(something.GetType()); } // Outputs: // AasCore.Aas3_1.Submodel // AasCore.Aas3_1.Property } } Errors If there are any errors during the de-serialization, a Jsonization.Exception will be thrown. Errors occur whenever we encounter invalid JSON values. For example, the de-serialization method expects a JSON object, but encounters a JSON array instead."
  },
  "getting_started/verify.html": {
    "href": "getting_started/verify.html",
    "title": "Verify",
    "keywords": "Verify Our SDK allows you to verify that a model satisfies the constraints of the meta-model. The verification logic is concentrated in the static class Verification , and all it takes is a call to Verify method. The method Verify will check that constraints in the given model element are satisfied, including the recursion into children elements. The method returns an iterator of errors, which you can use to for further processing ( e.g. , report to the user). Here is a short example snippet: using System.Collections.Generic; using System.Linq; using Aas = AasCore.Aas3_1; using AasVerification = AasCore.Aas3_1.Verification; using AasReporting = AasCore.Aas3_1.Reporting; public class Program { public static void Main() { // Prepare the environment var someProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { // ðŸ—²ðŸ—²ðŸ’€ðŸ—²ðŸ—² // The ID-shorts must be proper variable names, // but there is a dash (\"-\") in this ID-short. IdShort = \"some-Property\", }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { someProperty } }; var environment = new Aas.Environment() { Submodels = new List<Aas.ISubmodel>() { submodel } }; // Verify the environment and print out the errors foreach (var error in AasVerification.Verify(environment)) { System.Console.WriteLine( error.Cause ); } // Outputs: // Invariant violated: // ID-short of Referables shall only feature letters, digits, underscore (``_``); // starting mandatory with a letter. *I.e.* ``[a-zA-Z][a-zA-Z0-9_]+``. } } Reporting The error is an instance of Error , living in the scope of the static class Reporting . You can use the methods GenerateJsonPath and GenerateRelativeXPath to convert the error's path to a readable path. Here is the above snippet modified so that the path is included in the prints: // ... using AasVerification = AasCore.Aas3_1.Verification; using AasReporting = AasCore.Aas3_1.Reporting; public class Program { public static void Main() { // ... // Verify the environment and print out the errors foreach (var error in AasVerification.Verify(environment)) { System.Console.WriteLine( AasReporting.GenerateJsonPath(error.PathSegments) + \": \" + error.Cause ); } // Outputs: // submodels[0].submodelElements[0].idShort: Invariant violated: // ID-short of Referables shall only feature letters, digits, underscore (``_``); // starting mandatory with a letter. *I.e.* ``[a-zA-Z][a-zA-Z0-9_]+``. } } Limit the Number of Reported Errors Since the Verify method of the static class Verification gives you an iterator (an IEnumerable ), you can simply stop the verification after observing a certain number of errors. Here is a snippet which reports only the first 10 errors: // Verify the environment and print out the first 10 errors int errorCount = 0; foreach (var error in AasVerification.Verify(environment)) { System.Console.WriteLine(error.Cause); errorCount++; if (errorCount == 10) break; } Omitted Constraints Not all constraints specified in the meta-model can be verified. Some constraints require external dependencies such as an AAS registry. Verifying the constraints with external dependencies is out-of-scope of our SDK, as we still lack standardized interfaces to those dependencies. However, all the constraints which need no external dependency are verified. For a full list of exception, consult the aas-core-meta description of the meta-model which this SDK has been generated after."
  },
  "getting_started/xmlize.html": {
    "href": "getting_started/xmlize.html",
    "title": "XML De/serialization",
    "keywords": "XML De/serialization The code that de/serializes AAS models from and to XML documents lives in the static class Xmlization . Serialize You serialize a model using the static class Xmlization.Serialize by calling its To method on an Environment . The To method writes to a System.Xml.XmlWriter . Here is an example snippet: using System.Collections.Generic; using Aas = AasCore.Aas3_1; using AasXmlization = AasCore.Aas3_1.Xmlization; public class Program { public static void Main() { // Prepare the environment var someProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"someProperty\", }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { someProperty } }; var environment = new Aas.Environment() { Submodels = new List<Aas.ISubmodel>() { submodel } }; // Serialize to an XML writer var outputBuilder = new System.Text.StringBuilder(); using var writer = System.Xml.XmlWriter.Create( outputBuilder, new System.Xml.XmlWriterSettings() { Encoding = System.Text.Encoding.UTF8 } ); AasXmlization.Serialize.To( environment, writer ); writer.Flush(); // Print the output System.Console.WriteLine( outputBuilder.ToString() ); // Outputs (all on a single line): // <?xml version=\"1.0\" encoding=\"utf-16\"?> // <environment xmlns=\"https://admin-shell.io/aas/3/0\"> // <submodels><submodel> // <id>some-unique-global-identifier</id> // <submodelElements><property><idShort>someProperty</idShort> // <valueType>xs:boolean</valueType></property></submodelElements> // </submodel></submodels></environment> } } De-serialize The de-serialization is encapsulated in Xmlization.Deserialize static class. The crucial method is EnvironmentFrom which reads from an System.Xml.XmlReader and re-creates back an instance of Environment . The methods *From from Xmlization.Deserialize expect the reader to already point to the XML element of the instance. If you have non-content fields, such as an XML declaration, you have to invoke System.Xml.XmlReader.MoveToContent first. Here is a snippet which parses XML as text and then de-serializes it into an instance of Environment : using System.Collections.Generic; using Aas = AasCore.Aas3_1; using AasXmlization = AasCore.Aas3_1.Xmlization; public class Program { public static void Main() { var text = ( \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\" + \"<environment xmlns=\\\"https://admin-shell.io/aas/3/0\\\">\" + \"<submodels><submodel>\" + \"<id>some-unique-global-identifier</id>\" + \"<submodelElements><property><idShort>someProperty</idShort>\" + \"<valueType>xs:boolean</valueType></property></submodelElements>\" + \"</submodel></submodels></environment>\" ); using var stringReader = new System.IO.StringReader( text); using var xmlReader = System.Xml.XmlReader.Create( stringReader); // This step is necessary to skip the non-content. Otherwise, // the deserialization would have thrown an exception. xmlReader.MoveToContent(); var environment = AasXmlization.Deserialize.EnvironmentFrom( xmlReader); // Print the types of the model elements contained // in the environment foreach (var something in environment.Descend()) { System.Console.WriteLine(something.GetType()); } // Outputs: // AasCore.Aas3_1.Submodel // AasCore.Aas3_1.Property } } Errors If the XML document from System.Xml.XmlReader comes in an unexpected form, our SDK throws a Xmlization.Exception . This can happen, for example, if unexpected XML elements or XML attributes are encountered, or an expected XML element is missing."
  },
  "index.html": {
    "href": "index.html",
    "title": "aas-core 3.1 C#",
    "keywords": "aas-core 3.1 C# This is a software development kit (SDK) to: manipulate, verify, and de/serialize to and from JSON and XML ... Asset Administration Shells based on the version 3.1 of the meta-model . For a brief introduction, see Getting Started . For a detailed documentation of the API, see API ."
  }
}